/**
 * AIé©±åŠ¨çš„åˆ†é•œç”Ÿæˆå™¨ - Expressæ¨¡å¼
 * åŸºäºåœºæ™¯æ‹†åˆ†å’Œè¿é•œä¼˜åŒ–,ç”Ÿæˆå®Œæ•´çš„AIé©±åŠ¨åˆ†é•œè„šæœ¬
 */

import type {
  Storyboard,
  Scene,
  Shot,
  ProductionPack,
  CharacterSheet,
  SceneSheet,
  WorkspaceType,
} from '../types/index.js';
import { splitSceneIntoShots, type SceneSplitResult } from './scene-splitter.js';
import { optimizeCameraParameters, type CameraOptimizationContext } from './camera-optimizer.js';
import { WORKSPACE_CONFIGS } from '../workspaces/configs.js';

export interface AIStoryboardOptions {
  workspace: WorkspaceType;
  style_preference?: 'cinematic' | 'dynamic' | 'minimal'; // é£æ ¼åå¥½
  detail_level?: 'basic' | 'detailed' | 'comprehensive'; // ç»†èŠ‚ç¨‹åº¦
}

/**
 * ä»åœºæ™¯å†…å®¹æå–å…³é”®ä¿¡æ¯
 */
function extractSceneElements(scene: Scene): {
  characters: string[];
  actions: string[];
  dialogues: string[];
  emotions: string[];
} {
  const content = scene.content;

  // æå–è§’è‰²(ç®€å•å®ç°,å®é™…å¯ç”¨NLP)
  const character_matches = content.match(/([A-Z][a-z]+|[\u4e00-\u9fa5]{2,4}):/g) || [];
  const characters = [...new Set(character_matches.map(m => m.replace(':', '')))];

  // æå–åŠ¨ä½œ
  const action_keywords = ['èµ°', 'è·‘', 'å', 'ç«™', 'è½¬èº«', 'æ¨å¼€', 'æ‹¿èµ·', 'æ”¾ä¸‹', 'çœ‹å‘', 'ç¦»å¼€'];
  const actions = action_keywords.filter(kw => content.includes(kw));

  // æå–å¯¹è¯
  const dialogue_pattern = /[ã€Œã€"]([^ã€ã€"]+)[ã€ã€"]/g;
  const dialogues: string[] = [];
  let match;
  while ((match = dialogue_pattern.exec(content)) !== null) {
    dialogues.push(match[1]);
  }

  // æå–æƒ…ç»ª
  const emotion_keywords = ['æ„¤æ€’', 'æ‚²ä¼¤', 'å–œæ‚¦', 'ç´§å¼ ', 'å¹³é™', 'ææƒ§', 'æƒŠè®¶', 'å›°æƒ‘'];
  const emotions = emotion_keywords.filter(kw => content.includes(kw));

  return { characters, actions, dialogues, emotions };
}

/**
 * ä¸ºå•ä¸ªé•œå¤´ç”Ÿæˆè¯¦ç»†å†…å®¹
 */
function generateShotContent(
  scene: Scene,
  sceneSheet: SceneSheet,
  characterSheets: CharacterSheet[],
  shot_plan: SceneSplitResult['shot_plans'][0],
  shot_index: number,
  total_shots: number
): Partial<Shot> {
  const { characters, actions, dialogues } = extractSceneElements(scene);
  const progress = shot_index / total_shots;

  // ç”Ÿæˆé•œå¤´å†…å®¹æè¿°
  let content_parts: string[] = [];

  // å¦‚æœæ˜¯å¼€åœºé•œå¤´,æè¿°ç¯å¢ƒ
  if (shot_index === 0) {
    content_parts.push(`${scene.name}ã€‚${sceneSheet.layout_description}`);
  }

  // æ·»åŠ è§’è‰²å’ŒåŠ¨ä½œ
  if (characters.length > 0 && shot_index < characters.length) {
    const char_name = characters[shot_index];
    const char_sheet = characterSheets.find(cs => cs.name === char_name);
    if (char_sheet) {
      content_parts.push(`${char_name}${char_sheet.appearance.build || ''}`);
    }
  }

  // æ·»åŠ å¯¹è¯(å¦‚æœæœ‰)
  if (dialogues.length > 0 && shot_index < dialogues.length) {
    content_parts.push(`å¯¹è¯: "${dialogues[shot_index]}"`);
  }

  // æ·»åŠ åŠ¨ä½œ(å¦‚æœæœ‰)
  if (actions.length > 0) {
    const action_index = shot_index % actions.length;
    content_parts.push(`åŠ¨ä½œ: ${actions[action_index]}`);
  }

  // å¦‚æœæ²¡æœ‰è¶³å¤Ÿå†…å®¹,ä½¿ç”¨åœºæ™¯å†…å®¹ç‰‡æ®µ
  if (content_parts.length < 2) {
    const scene_length = scene.content.length;
    const start = Math.floor((progress * scene_length));
    const end = Math.min(start + 100, scene_length);
    const snippet = scene.content.substring(start, end);
    content_parts.push(snippet);
  }

  return {
    shot_number: shot_index + 1,
    shot_type: shot_plan.suggested_shot_type as Shot['shot_type'],
    camera_angle: shot_plan.suggested_angle as Shot['camera_angle'],
    content: content_parts.join('ã€‚'),
  };
}

/**
 * ç”Ÿæˆæƒ…ç»ªæ ‡æ³¨
 */
function generateMoodAnnotation(
  scene: Scene,
  shot_index: number,
  total_shots: number
): Shot['mood'] {
  const { emotions } = extractSceneElements(scene);
  const progress = shot_index / total_shots;

  let emotional_tone = 'å¹³é™';
  if (emotions.length > 0) {
    // æ ¹æ®è¿›åº¦é€‰æ‹©æƒ…ç»ª
    const emotion_index = Math.floor(progress * emotions.length);
    emotional_tone = emotions[emotion_index] || emotions[0];
  }

  return {
    emotional_tone,
    lighting_suggestion: emotional_tone.includes('ç´§å¼ ') || emotional_tone.includes('ææƒ§')
      ? 'ä½è°ƒç…§æ˜,å¼ºå¯¹æ¯”'
      : emotional_tone.includes('å–œæ‚¦')
        ? 'æ˜äº®æŸ”å’Œ'
        : 'è‡ªç„¶å…‰',
    color_grading: emotional_tone.includes('æ‚²ä¼¤')
      ? 'å†·è‰²è°ƒ,ä½é¥±å’Œåº¦'
      : emotional_tone.includes('æ„¤æ€’')
        ? 'æš–è‰²è°ƒ,é«˜å¯¹æ¯”'
        : 'ä¸­æ€§è‰²è°ƒ',
  };
}

/**
 * ç”ŸæˆåŠ¨æ€æ•ˆæœ
 */
function generateShotEffects(shot_type: string, pacing: string): Shot['effects'] {
  return {
    speed_ramp: pacing === 'fast' ? 'å¿«è¿›' : undefined,
    blur: shot_type.includes('ç‰¹å†™') ? 'èƒŒæ™¯è™šåŒ–' : undefined,
    color_filter: undefined,
  };
}

/**
 * ç”Ÿæˆå·¥ä½œåŒºç‰¹å®šå­—æ®µ
 */
function generateWorkspaceFields(
  workspace: WorkspaceType,
  shot_index: number,
  total_shots: number
): Shot['workspace_fields'] {
  const config = WORKSPACE_CONFIGS[workspace];

  if (workspace === 'manga') {
    // æ¼«ç”»å·¥ä½œåŒº
    const is_page_break = (shot_index + 1) % 4 === 0; // æ¯4ä¸ªé•œå¤´ç¿»é¡µ
    return {
      page_break: is_page_break,
      bubble_position: shot_index % 2 === 0 ? 'å·¦ä¸Š' : 'å³ä¸Š',
      panel_layout: shot_index % 3 === 0 ? 'å…¨é¡µ' : 'åŠé¡µ',
    };
  } else if (workspace === 'short-video') {
    // çŸ­è§†é¢‘å·¥ä½œåŒº
    const timeline_seconds = shot_index * 3; // æ¯ä¸ªé•œå¤´3ç§’
    const minutes = Math.floor(timeline_seconds / 60);
    const seconds = timeline_seconds % 60;
    return {
      timeline: `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`,
      subtitle: 'å­—å¹•å†…å®¹å¾…å¡«å……',
      subtitle_style: {
        font: 'PingFang SC',
        size: 24,
        color: '#FFFFFF',
        position: 'bottom-center',
      },
      voiceover: {
        voice_type: 'neutral',
        speed: 1.0,
        volume: 0.8,
      },
    };
  } else if (workspace === 'dynamic-manga') {
    // åŠ¨æ€æ¼«å·¥ä½œåŒº
    return {
      frame_range: `${shot_index * 24}-${(shot_index + 1) * 24}`, // 24fps
      layer_structure: ['èƒŒæ™¯å±‚', 'äººç‰©å±‚', 'ç‰¹æ•ˆå±‚', 'å­—å¹•å±‚'],
      params_3d: {
        camera_fov: 50,
        camera_distance: 10,
      },
      vfx_params: {
        particle_effects: [],
        screen_effects: [],
      },
    };
  }

  return undefined;
}

/**
 * Expressæ¨¡å¼: å®Œå…¨è‡ªåŠ¨ç”Ÿæˆåˆ†é•œ
 */
export async function generateExpressStoryboard(
  productionPack: ProductionPack,
  options: AIStoryboardOptions
): Promise<Storyboard> {
  const { character_sheets, scene_sheets, source_data } = productionPack;
  const scenes = source_data.scenes;

  console.log(`\nğŸš€ Expressæ¨¡å¼: å¼€å§‹AIé©±åŠ¨åˆ†é•œç”Ÿæˆ...\n`);

  // 1. ç”Ÿæˆåœºæ™¯æ‹†åˆ†è§„åˆ’
  console.log('ğŸ“Š æ­¥éª¤ 1/4: åˆ†æåœºæ™¯å¤æ‚åº¦å¹¶ç”Ÿæˆé•œå¤´è§„åˆ’...');
  const split_results = scenes.map(scene => {
    const sheet = scene_sheets.find(s => s.scene_id === scene.id);
    return splitSceneIntoShots(scene, sheet);
  });

  const total_shots = split_results.reduce((sum, r) => sum + r.estimated_shots, 0);
  console.log(`   âœ“ è§„åˆ’å®Œæˆ: ${scenes.length}ä¸ªåœºæ™¯, é¢„è®¡${total_shots}ä¸ªé•œå¤´\n`);

  // 2. ä¸ºæ¯ä¸ªåœºæ™¯ç”Ÿæˆé•œå¤´
  console.log('ğŸ¬ æ­¥éª¤ 2/4: ç”Ÿæˆè¯¦ç»†é•œå¤´å†…å®¹...');
  const storyboard_scenes: Storyboard['scenes'] = [];
  let global_shot_number = 1;

  for (const [scene_index, scene] of scenes.entries()) {
    const split_result = split_results[scene_index];
    const scene_sheet = scene_sheets.find(s => s.scene_id === scene.id)!;

    console.log(`   åœºæ™¯ ${scene_index + 1}/${scenes.length}: ${scene.name} (${split_result.estimated_shots}ä¸ªé•œå¤´, ${split_result.pacing}èŠ‚å¥)`);

    const shots: Shot[] = [];

    for (const [shot_index, shot_plan] of split_result.shot_plans.entries()) {
      // ç”ŸæˆåŸºç¡€é•œå¤´å†…å®¹
      const shot_base = generateShotContent(
        scene,
        scene_sheet,
        character_sheets,
        shot_plan,
        shot_index,
        split_result.estimated_shots
      );

      // ä¼˜åŒ–è¿é•œå‚æ•°
      const shot_position: CameraOptimizationContext['shot_position'] =
        shot_index === 0
          ? 'opening'
          : shot_index === split_result.estimated_shots - 1
            ? 'closing'
            : shot_index / split_result.estimated_shots > 0.6
              ? 'climax'
              : 'middle';

      const optimized_camera = optimizeCameraParameters({
        shot_type: shot_base.shot_type!,
        scene_pacing: split_result.pacing,
        mood: undefined,
        is_dialogue: shot_base.content?.includes('å¯¹è¯') || false,
        is_action: shot_base.content?.includes('åŠ¨ä½œ') || false,
        shot_position,
      });

      // ç»„è£…å®Œæ•´é•œå¤´
      const shot: Shot = {
        shot_number: global_shot_number++,
        shot_type: shot_base.shot_type!,
        camera_angle: optimized_camera.angle.type,
        content: shot_base.content!,
        camera_movement: {
          type: optimized_camera.movement.type,
          speed: optimized_camera.movement.speed,
          description: optimized_camera.movement.description,
        },
        mood: generateMoodAnnotation(scene, shot_index, split_result.estimated_shots),
        effects: generateShotEffects(shot_base.shot_type!, split_result.pacing),
        workspace_fields: generateWorkspaceFields(
          options.workspace,
          shot_index,
          split_result.estimated_shots
        ),
      };

      shots.push(shot);
    }

    storyboard_scenes.push({
      scene_id: scene.id,
      scene_name: scene.name,
      shots,
    });
  }

  console.log(`   âœ“ ${total_shots}ä¸ªé•œå¤´ç”Ÿæˆå®Œæˆ\n`);

  // 3. ç”Ÿæˆå…ƒæ•°æ®
  console.log('ğŸ“ æ­¥éª¤ 3/4: ç”Ÿæˆå…ƒæ•°æ®...');
  const workspace_config = WORKSPACE_CONFIGS[options.workspace];

  let estimated_duration: string | undefined;
  let estimated_pages: string | undefined;

  if (options.workspace === 'short-video' || options.workspace === 'dynamic-manga') {
    const total_seconds = total_shots * 3; // å‡è®¾æ¯ä¸ªé•œå¤´3ç§’
    const minutes = Math.floor(total_seconds / 60);
    const seconds = total_seconds % 60;
    estimated_duration = `${minutes}åˆ†${seconds}ç§’`;
  }

  if (options.workspace === 'manga') {
    estimated_pages = `${Math.ceil(total_shots / 4)}é¡µ`; // å‡è®¾æ¯é¡µ4æ ¼
  }

  console.log(`   âœ“ é¢„ä¼°${estimated_duration || estimated_pages || 'å®Œæˆ'}\n`);

  // 4. ç»„è£…å®Œæ•´åˆ†é•œè„šæœ¬
  console.log('âœ… æ­¥éª¤ 4/4: ç»„è£…åˆ†é•œè„šæœ¬...\n');

  const storyboard: Storyboard = {
    version: '1.0',
    metadata: {
      title: source_data.scripts[0]?.title || 'æœªå‘½å',
      workspace: options.workspace,
      workspace_display_name: workspace_config.display_name,
      aspect_ratio: workspace_config.aspect_ratio,
      total_scenes: scenes.length,
      total_shots,
      estimated_duration,
      estimated_pages,
      generation_mode: 'express',
      created_at: new Date().toISOString(),
    },
    scenes: storyboard_scenes,
    production_pack_reference: {
      characters: character_sheets.map(cs => cs.id),
      scenes: scene_sheets.map(ss => ss.scene_id),
    },
  };

  console.log('ğŸ‰ Expressæ¨¡å¼åˆ†é•œç”Ÿæˆå®Œæˆ!\n');
  console.log(`æ€»è®¡: ${scenes.length}ä¸ªåœºæ™¯, ${total_shots}ä¸ªé•œå¤´`);
  console.log(`å·¥ä½œåŒº: ${workspace_config.display_name}`);
  console.log(`é¢„ä¼°: ${estimated_duration || estimated_pages || 'N/A'}\n`);

  return storyboard;
}
